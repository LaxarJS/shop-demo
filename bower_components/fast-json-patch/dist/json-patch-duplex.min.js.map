{"version":3,"file":"json-patch-duplex.min.js","sources":["../src/json-patch-duplex.js"],"names":["jsonpatch","escapePathComponent","str","indexOf","replace","_getPathRecursive","root","obj","found","key","hasOwnProperty","getPath","path","Error","getMirror","i","ilen","beforeDict","length","getObserverFromMirror","mirror","callback","j","jlen","observers","observer","removeObserverFromMirror","splice","unobserve","generate","Object","observe","_unobserve","clearTimeout","next","patches","Mirror","push","arr","_observe","a","alen","name","_isArray","object","type","observeOps","call","value","JSON","parse","stringify","intervals","this","currentInterval","dirtyCheck","fastCheck","setTimeout","slowCheck","window","addEventListener","attachEvent","ObserverInfo","v","deliverChangeRecords","_generate","temp","newKeys","_objectKeys","oldKeys","changed","deleted","t","oldVal","newVal","op","apply","tree","patch","result","p","plen","keys","split","len","index","parseInt","arrOps","objOps","compare","tree1","tree2","add","remove","move","from","copy","test","_get","delete","update","o","Array","isArray","exports"],"mappings":"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","sourcesContent":["/*!\n* json-patch-duplex.js 0.3.8\n* (c) 2013 Joachim Wester\n* MIT license\n*/\n\nvar jsonpatch;\n(function (jsonpatch) {\n    /* We use a Javascript hash to store each\n    function. Each hash entry (property) uses\n    the operation identifiers specified in rfc6902.\n    In this way, we can map each patch operation\n    to its dedicated function in efficient way.\n    */\n    /* The operations applicable to an object */\n    var objOps = {\n        add: function (obj, key) {\n            obj[key] = this.value;\n            return true;\n        },\n        remove: function (obj, key) {\n            delete obj[key];\n            return true;\n        },\n        replace: function (obj, key) {\n            obj[key] = this.value;\n            return true;\n        },\n        move: function (obj, key, tree) {\n            var temp = { op: \"_get\", path: this.from };\n            apply(tree, [temp]);\n            apply(tree, [\n                { op: \"remove\", path: this.from }\n            ]);\n            apply(tree, [\n                { op: \"add\", path: this.path, value: temp.value }\n            ]);\n            return true;\n        },\n        copy: function (obj, key, tree) {\n            var temp = { op: \"_get\", path: this.from };\n            apply(tree, [temp]);\n            apply(tree, [\n                { op: \"add\", path: this.path, value: temp.value }\n            ]);\n            return true;\n        },\n        test: function (obj, key) {\n            return (JSON.stringify(obj[key]) === JSON.stringify(this.value));\n        },\n        _get: function (obj, key) {\n            this.value = obj[key];\n        }\n    };\n\n    /* The operations applicable to an array. Many are the same as for the object */\n    var arrOps = {\n        add: function (arr, i) {\n            arr.splice(i, 0, this.value);\n            return true;\n        },\n        remove: function (arr, i) {\n            arr.splice(i, 1);\n            return true;\n        },\n        replace: function (arr, i) {\n            arr[i] = this.value;\n            return true;\n        },\n        move: objOps.move,\n        copy: objOps.copy,\n        test: objOps.test,\n        _get: objOps._get\n    };\n\n    var observeOps = {\n        add: function (patches, path) {\n            var patch = {\n                op: \"add\",\n                path: path + escapePathComponent(this.name),\n                value: this.object[this.name] };\n            patches.push(patch);\n        },\n        'delete': function (patches, path) {\n            var patch = {\n                op: \"remove\",\n                path: path + escapePathComponent(this.name)\n            };\n            patches.push(patch);\n        },\n        update: function (patches, path) {\n            var patch = {\n                op: \"replace\",\n                path: path + escapePathComponent(this.name),\n                value: this.object[this.name]\n            };\n            patches.push(patch);\n        }\n    };\n\n    function escapePathComponent(str) {\n        if (str.indexOf('/') === -1 && str.indexOf('~') === -1)\n            return str;\n        return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n    }\n\n    function _getPathRecursive(root, obj) {\n        var found;\n        for (var key in root) {\n            if (root.hasOwnProperty(key)) {\n                if (root[key] === obj) {\n                    return escapePathComponent(key) + '/';\n                } else if (typeof root[key] === 'object') {\n                    found = _getPathRecursive(root[key], obj);\n                    if (found != '') {\n                        return escapePathComponent(key) + '/' + found;\n                    }\n                }\n            }\n        }\n        return '';\n    }\n\n    function getPath(root, obj) {\n        if (root === obj) {\n            return '/';\n        }\n        var path = _getPathRecursive(root, obj);\n        if (path === '') {\n            throw new Error(\"Object not found in root\");\n        }\n        return '/' + path;\n    }\n\n    var beforeDict = [];\n\n    jsonpatch.intervals;\n\n    var Mirror = (function () {\n        function Mirror(obj) {\n            this.observers = [];\n            this.obj = obj;\n        }\n        return Mirror;\n    })();\n\n    var ObserverInfo = (function () {\n        function ObserverInfo(callback, observer) {\n            this.callback = callback;\n            this.observer = observer;\n        }\n        return ObserverInfo;\n    })();\n\n    function getMirror(obj) {\n        for (var i = 0, ilen = beforeDict.length; i < ilen; i++) {\n            if (beforeDict[i].obj === obj) {\n                return beforeDict[i];\n            }\n        }\n    }\n\n    function getObserverFromMirror(mirror, callback) {\n        for (var j = 0, jlen = mirror.observers.length; j < jlen; j++) {\n            if (mirror.observers[j].callback === callback) {\n                return mirror.observers[j].observer;\n            }\n        }\n    }\n\n    function removeObserverFromMirror(mirror, observer) {\n        for (var j = 0, jlen = mirror.observers.length; j < jlen; j++) {\n            if (mirror.observers[j].observer === observer) {\n                mirror.observers.splice(j, 1);\n                return;\n            }\n        }\n    }\n\n    function unobserve(root, observer) {\n        generate(observer);\n        if (Object.observe) {\n            _unobserve(observer, root);\n        } else {\n            clearTimeout(observer.next);\n        }\n\n        var mirror = getMirror(root);\n        removeObserverFromMirror(mirror, observer);\n    }\n    jsonpatch.unobserve = unobserve;\n\n    function observe(obj, callback) {\n        var patches = [];\n        var root = obj;\n        var observer;\n        var mirror = getMirror(obj);\n\n        if (!mirror) {\n            mirror = new Mirror(obj);\n            beforeDict.push(mirror);\n        } else {\n            observer = getObserverFromMirror(mirror, callback);\n        }\n\n        if (observer) {\n            return observer;\n        }\n\n        if (Object.observe) {\n            observer = function (arr) {\n                //This \"refresh\" is needed to begin observing new object properties\n                _unobserve(observer, obj);\n                _observe(observer, obj);\n\n                var a = 0, alen = arr.length;\n                while (a < alen) {\n                    if (!(arr[a].name === 'length' && _isArray(arr[a].object)) && !(arr[a].name === '__Jasmine_been_here_before__')) {\n                        var type = arr[a].type;\n\n                        switch (type) {\n                            case 'new':\n                                type = 'add';\n                                break;\n\n                            case 'deleted':\n                                type = 'delete';\n                                break;\n\n                            case 'updated':\n                                type = 'update';\n                                break;\n                        }\n\n                        observeOps[type].call(arr[a], patches, getPath(root, arr[a].object));\n                    }\n                    a++;\n                }\n\n                if (patches) {\n                    if (callback) {\n                        callback(patches);\n                    }\n                }\n                observer.patches = patches;\n                patches = [];\n            };\n        } else {\n            observer = {};\n\n            mirror.value = JSON.parse(JSON.stringify(obj)); // Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5\n\n            if (callback) {\n                //callbacks.push(callback); this has no purpose\n                observer.callback = callback;\n                observer.next = null;\n                var intervals = this.intervals || [100, 1000, 10000, 60000];\n                if (intervals.push === void 0) {\n                    throw new Error(\"jsonpatch.intervals must be an array\");\n                }\n                var currentInterval = 0;\n\n                var dirtyCheck = function () {\n                    generate(observer);\n                };\n                var fastCheck = function () {\n                    clearTimeout(observer.next);\n                    observer.next = setTimeout(function () {\n                        dirtyCheck();\n                        currentInterval = 0;\n                        observer.next = setTimeout(slowCheck, intervals[currentInterval++]);\n                    }, 0);\n                };\n                var slowCheck = function () {\n                    dirtyCheck();\n                    if (currentInterval == intervals.length)\n                        currentInterval = intervals.length - 1;\n                    observer.next = setTimeout(slowCheck, intervals[currentInterval++]);\n                };\n                if (typeof window !== 'undefined') {\n                    if (window.addEventListener) {\n                        window.addEventListener('mousedown', fastCheck);\n                        window.addEventListener('mouseup', fastCheck);\n                        window.addEventListener('keydown', fastCheck);\n                    } else {\n                        window.attachEvent('onmousedown', fastCheck);\n                        window.attachEvent('onmouseup', fastCheck);\n                        window.attachEvent('onkeydown', fastCheck);\n                    }\n                }\n                observer.next = setTimeout(slowCheck, intervals[currentInterval++]);\n            }\n        }\n        observer.patches = patches;\n        observer.object = obj;\n\n        mirror.observers.push(new ObserverInfo(callback, observer));\n\n        return _observe(observer, obj);\n    }\n    jsonpatch.observe = observe;\n\n    /// Listen to changes on an object tree, accumulate patches\n    function _observe(observer, obj) {\n        if (Object.observe) {\n            Object.observe(obj, observer);\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    var v = obj[key];\n                    if (v && typeof (v) === \"object\") {\n                        _observe(observer, v);\n                    }\n                }\n            }\n        }\n        return observer;\n    }\n\n    function _unobserve(observer, obj) {\n        if (Object.observe) {\n            Object.unobserve(obj, observer);\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    var v = obj[key];\n                    if (v && typeof (v) === \"object\") {\n                        _unobserve(observer, v);\n                    }\n                }\n            }\n        }\n        return observer;\n    }\n\n    function generate(observer) {\n        if (Object.observe) {\n            Object.deliverChangeRecords(observer);\n        } else {\n            var mirror;\n            for (var i = 0, ilen = beforeDict.length; i < ilen; i++) {\n                if (beforeDict[i].obj === observer.object) {\n                    mirror = beforeDict[i];\n                    break;\n                }\n            }\n            _generate(mirror.value, observer.object, observer.patches, \"\");\n        }\n        var temp = observer.patches;\n        if (temp.length > 0) {\n            observer.patches = [];\n            if (observer.callback) {\n                observer.callback(temp);\n            }\n        }\n        return temp;\n    }\n    jsonpatch.generate = generate;\n\n    var _objectKeys;\n    if (Object.keys) {\n        _objectKeys = Object.keys;\n    } else {\n        _objectKeys = function (obj) {\n            var keys = [];\n            for (var o in obj) {\n                if (obj.hasOwnProperty(o)) {\n                    keys.push(o);\n                }\n            }\n            return keys;\n        };\n    }\n\n    // Dirty check if obj is different from mirror, generate patches and update mirror\n    function _generate(mirror, obj, patches, path) {\n        var newKeys = _objectKeys(obj);\n        var oldKeys = _objectKeys(mirror);\n        var changed = false;\n        var deleted = false;\n\n        for (var t = oldKeys.length - 1; t >= 0; t--) {\n            var key = oldKeys[t];\n            var oldVal = mirror[key];\n            if (obj.hasOwnProperty(key)) {\n                var newVal = obj[key];\n                if (oldVal instanceof Object) {\n                    _generate(oldVal, newVal, patches, path + \"/\" + escapePathComponent(key));\n                } else {\n                    if (oldVal != newVal) {\n                        changed = true;\n                        patches.push({ op: \"replace\", path: path + \"/\" + escapePathComponent(key), value: newVal });\n                        mirror[key] = newVal;\n                    }\n                }\n            } else {\n                patches.push({ op: \"remove\", path: path + \"/\" + escapePathComponent(key) });\n                delete mirror[key];\n                deleted = true; // property has been deleted\n            }\n        }\n\n        if (!deleted && newKeys.length == oldKeys.length) {\n            return;\n        }\n\n        for (var t = 0; t < newKeys.length; t++) {\n            var key = newKeys[t];\n            if (!mirror.hasOwnProperty(key)) {\n                patches.push({ op: \"add\", path: path + \"/\" + escapePathComponent(key), value: obj[key] });\n                mirror[key] = JSON.parse(JSON.stringify(obj[key]));\n            }\n        }\n    }\n\n    var _isArray;\n    if (Array.isArray) {\n        _isArray = Array.isArray;\n    } else {\n        _isArray = function (obj) {\n            return obj.push && typeof obj.length === 'number';\n        };\n    }\n\n    /// Apply a json-patch operation on an object tree\n    function apply(tree, patches) {\n        var result = false, p = 0, plen = patches.length, patch;\n        while (p < plen) {\n            patch = patches[p];\n\n            // Find the object\n            var keys = patch.path.split('/');\n            var obj = tree;\n            var t = 1;\n            var len = keys.length;\n            while (true) {\n                if (_isArray(obj)) {\n                    var index = parseInt(keys[t], 10);\n                    t++;\n                    if (t >= len) {\n                        result = arrOps[patch.op].call(patch, obj, index, tree); // Apply patch\n                        break;\n                    }\n                    obj = obj[index];\n                } else {\n                    var key = keys[t];\n                    if (key.indexOf('~') != -1)\n                        key = key.replace(/~1/g, '/').replace(/~0/g, '~'); // escape chars\n                    t++;\n                    if (t >= len) {\n                        result = objOps[patch.op].call(patch, obj, key, tree); // Apply patch\n                        break;\n                    }\n                    obj = obj[key];\n                }\n            }\n            p++;\n        }\n        return result;\n    }\n    jsonpatch.apply = apply;\n\n    function compare(tree1, tree2) {\n        var patches = [];\n        _generate(tree1, tree2, patches, '');\n        return patches;\n    }\n    jsonpatch.compare = compare;\n})(jsonpatch || (jsonpatch = {}));\n\nif (typeof exports !== \"undefined\") {\n    exports.apply = jsonpatch.apply;\n    exports.observe = jsonpatch.observe;\n    exports.unobserve = jsonpatch.unobserve;\n    exports.generate = jsonpatch.generate;\n}\n"]}